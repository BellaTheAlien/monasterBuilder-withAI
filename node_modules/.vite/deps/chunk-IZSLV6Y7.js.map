{
  "version": 3,
  "sources": ["../../@langchain/core/dist/tools/index.js"],
  "sourcesContent": ["import { z } from \"zod/v3\";\nimport { validate, } from \"@cfworker/json-schema\";\nimport { CallbackManager, parseCallbackConfigArg, } from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../language_models/base.js\";\nimport { ensureConfig, patchConfig, pickRunnableConfigKeys, } from \"../runnables/config.js\";\nimport { isDirectToolOutput, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { _configHasToolCallId, _isToolCall, ToolInputParsingException, } from \"./utils.js\";\nimport { interopParseAsync, isSimpleStringZodSchema, isInteropZodSchema, } from \"../utils/types/zod.js\";\nimport { validatesOnlyStrings } from \"../utils/json_schema.js\";\nexport { isLangChainTool, isRunnableToolLike, isStructuredTool, isStructuredToolParams, } from \"./types.js\";\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport class StructuredTool extends BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        /**\n         * Whether to return the tool's output directly.\n         *\n         * Setting this to true means that after the tool is called,\n         * an agent should stop looping.\n         */\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"verboseParsingErrors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * The tool response format.\n         *\n         * If \"content\" then the output of the tool is interpreted as the contents of a\n         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n         *\n         * @default \"content\"\n         */\n        Object.defineProperty(this, \"responseFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"content\"\n        });\n        this.verboseParsingErrors =\n            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with the tool's output.\n     */\n    async invoke(input, config) {\n        let toolInput;\n        let enrichedConfig = ensureConfig(config);\n        if (_isToolCall(input)) {\n            toolInput = input.args;\n            enrichedConfig = {\n                ...enrichedConfig,\n                toolCall: input,\n            };\n        }\n        else {\n            toolInput = input;\n        }\n        return this.call(toolInput, enrichedConfig);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        // Determine the actual input that needs parsing/validation.\n        // If arg is a ToolCall, use its args; otherwise, use arg directly.\n        const inputForValidation = _isToolCall(arg) ? arg.args : arg;\n        let parsed; // This will hold the successfully parsed input of the expected output type.\n        if (isInteropZodSchema(this.schema)) {\n            try {\n                // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n                parsed = await interopParseAsync(this.schema, inputForValidation);\n            }\n            catch (e) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${e.message}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new ToolInputParsingException(message, JSON.stringify(arg));\n            }\n        }\n        else {\n            const result = validate(inputForValidation, this.schema);\n            if (!result.valid) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${result.errors\n                        .map((e) => `${e.keywordLocation}: ${e.error}`)\n                        .join(\"\\n\")}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new ToolInputParsingException(message, JSON.stringify(arg));\n            }\n            // Assign the validated input to parsed\n            // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n            parsed = inputForValidation;\n        }\n        const config = parseCallbackConfigArg(configArg);\n        const callbackManager_ = CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), \n        // Log the original raw input arg\n        typeof arg === \"string\" ? arg : JSON.stringify(arg), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let result;\n        try {\n            // Pass the correctly typed parsed input to _call\n            result = await this._call(parsed, runManager, config);\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        let content;\n        let artifact;\n        if (this.responseFormat === \"content_and_artifact\") {\n            if (Array.isArray(result) && result.length === 2) {\n                [content, artifact] = result;\n            }\n            else {\n                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n            }\n        }\n        else {\n            content = result;\n        }\n        let toolCallId;\n        // Extract toolCallId ONLY if the original arg was a ToolCall\n        if (_isToolCall(arg)) {\n            toolCallId = arg.id;\n        }\n        // Or if it was provided in the config's toolCall property\n        if (!toolCallId && _configHasToolCallId(config)) {\n            toolCallId = config.toolCall.id;\n        }\n        const formattedOutput = _formatToolOutput({\n            content,\n            artifact,\n            toolCallId,\n            name: this.name,\n        });\n        await runManager?.handleToolEnd(formattedOutput);\n        return formattedOutput;\n    }\n}\n/**\n * Base class for Tools that accept input as a string.\n */\nexport class Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: z\n                .object({ input: z.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    // Match the base class signature including the generics and conditional return type\n    call(arg, callbacks) {\n        // Prepare the input for the base class call method.\n        // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n        const structuredArg = typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n        // Ensure TConfig is passed to super.call\n        return super.call(structuredArg, callbacks);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg) {\n        const config = parseCallbackConfigArg(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the Tool class's call method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager, parentConfig) {\n        return this.func(input, runManager, parentConfig);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nexport class DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = fields.schema;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    // Match the base class signature\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = parseCallbackConfigArg(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the base class method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, parentConfig) {\n        return this.func(arg, runManager, parentConfig);\n    }\n}\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport class BaseToolkit {\n    getTools() {\n        return this.tools;\n    }\n}\nexport function tool(func, fields) {\n    const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);\n    const isStringJSONSchema = validatesOnlyStrings(fields.schema);\n    // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n    if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n        return new DynamicTool({\n            ...fields,\n            description: fields.description ??\n                fields.schema?.description ??\n                `${fields.name} tool`,\n            func: async (input, runManager, config) => {\n                return new Promise((resolve, reject) => {\n                    const childConfig = patchConfig(config, {\n                        callbacks: runManager?.getChild(),\n                    });\n                    void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                        try {\n                            // TS doesn't restrict the type here based on the guard above\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            resolve(func(input, childConfig));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            },\n        });\n    }\n    const schema = fields.schema;\n    const description = fields.description ??\n        fields.schema.description ??\n        `${fields.name} tool`;\n    return new DynamicStructuredTool({\n        ...fields,\n        description,\n        schema,\n        func: async (input, runManager, config) => {\n            return new Promise((resolve, reject) => {\n                const childConfig = patchConfig(config, {\n                    callbacks: runManager?.getChild(),\n                });\n                void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                    try {\n                        resolve(func(input, childConfig));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            });\n        },\n    });\n}\nfunction _formatToolOutput(params) {\n    const { content, artifact, toolCallId } = params;\n    if (toolCallId && !isDirectToolOutput(content)) {\n        if (typeof content === \"string\" ||\n            (Array.isArray(content) &&\n                content.every((item) => typeof item === \"object\"))) {\n            return new ToolMessage({\n                content,\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n            });\n        }\n        else {\n            return new ToolMessage({\n                content: _stringify(content),\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n            });\n        }\n    }\n    else {\n        return content;\n    }\n}\nfunction _stringify(content) {\n    try {\n        return JSON.stringify(content, null, 2) ?? \"\";\n    }\n    catch (_noOp) {\n        return `${content}`;\n    }\n}\n"],
  "mappings": "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",
  "names": ["result"]
}
