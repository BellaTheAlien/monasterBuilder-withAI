import {
  VectorDBQAChain
} from "./chunk-T24JXGXI.js";
import "./chunk-TV4WZM57.js";
import {
  DynamicStructuredTool,
  DynamicTool,
  StructuredTool,
  Tool
} from "./chunk-IZSLV6Y7.js";
import {
  convertToOpenAIFunction,
  convertToOpenAITool
} from "./chunk-7GVXJ4SF.js";
import "./chunk-CAPD4ITG.js";
import "./chunk-7OV2D4Y5.js";
import "./chunk-AENRLI6M.js";
import "./chunk-7XYDZZFD.js";
import "./chunk-LXCUE2DN.js";
import "./chunk-EOEFBX3O.js";
import "./chunk-UG6RZFTO.js";
import "./chunk-SV6JEJTH.js";
import "./chunk-Y4UITVOS.js";
import "./chunk-6V4DS7VH.js";
import {
  Serializable,
  __commonJS,
  __toESM,
  external_exports
} from "./chunk-JZSBKBZ3.js";

// node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "node_modules/jsonpointer/jsonpointer.js"(exports) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    exports.get = get;
    exports.set = set;
    exports.compile = compile;
  }
});

// node_modules/langchain/dist/tools/chain.js
var ChainTool = class extends DynamicTool {
  static lc_name() {
    return "ChainTool";
  }
  constructor({ chain, ...rest }) {
    super({
      ...rest,
      func: async (input, runManager) => chain.run(input, runManager?.getChild())
    });
    Object.defineProperty(this, "chain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.chain = chain;
  }
};

// node_modules/langchain/dist/tools/json.js
var import_jsonpointer = __toESM(require_jsonpointer(), 1);
var JsonSpec = class extends Serializable {
  constructor(obj, max_value_length = 4e3) {
    super(...arguments);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "tools", "json"]
    });
    Object.defineProperty(this, "obj", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxValueLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4e3
    });
    this.obj = obj;
    this.maxValueLength = max_value_length;
  }
  /**
   * Retrieves all keys at a given path in the JSON object.
   * @param input The path to the keys in the JSON object, provided as a string in JSON pointer syntax.
   * @returns A string containing all keys at the given path, separated by commas.
   */
  getKeys(input) {
    const pointer = import_jsonpointer.default.compile(input);
    const res = pointer.get(this.obj);
    if (typeof res === "object" && !Array.isArray(res) && res !== null) {
      return Object.keys(res).map((i) => i.replaceAll("~", "~0").replaceAll("/", "~1")).join(", ");
    }
    throw new Error(`Value at ${input} is not a dictionary, get the value directly instead.`);
  }
  /**
   * Retrieves the value at a given path in the JSON object.
   * @param input The path to the value in the JSON object, provided as a string in JSON pointer syntax.
   * @returns The value at the given path in the JSON object, as a string. If the value is a large dictionary or exceeds the maximum length, a message is returned instead.
   */
  getValue(input) {
    const pointer = import_jsonpointer.default.compile(input);
    const res = pointer.get(this.obj);
    if (res === null || res === void 0) {
      throw new Error(`Value at ${input} is null or undefined.`);
    }
    const str = typeof res === "object" ? JSON.stringify(res) : res.toString();
    if (typeof res === "object" && !Array.isArray(res) && str.length > this.maxValueLength) {
      return `Value is a large dictionary, should explore its keys directly.`;
    }
    if (str.length > this.maxValueLength) {
      return `${str.slice(0, this.maxValueLength)}...`;
    }
    return str;
  }
};
var JsonListKeysTool = class extends Tool {
  static lc_name() {
    return "JsonListKeysTool";
  }
  constructor(fields) {
    if (!("jsonSpec" in fields)) {
      fields = { jsonSpec: fields };
    }
    super(fields);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "json_list_keys"
    });
    Object.defineProperty(this, "jsonSpec", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `Can be used to list all keys at a given path.
    Before calling this you should be SURE that the path to this exists.
    The input is a text representation of the path to the json as json pointer syntax (e.g. /key1/0/key2).`
    });
    this.jsonSpec = fields.jsonSpec;
  }
  /** @ignore */
  async _call(input) {
    try {
      return this.jsonSpec.getKeys(input);
    } catch (error) {
      return `${error}`;
    }
  }
};
var JsonGetValueTool = class extends Tool {
  static lc_name() {
    return "JsonGetValueTool";
  }
  constructor(jsonSpec) {
    super();
    Object.defineProperty(this, "jsonSpec", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: jsonSpec
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "json_get_value"
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `Can be used to see value in string format at a given path.
    Before calling this you should be SURE that the path to this exists.
    The input is a text representation of the path to the json as json pointer syntax (e.g. /key1/0/key2).`
    });
  }
  /** @ignore */
  async _call(input) {
    try {
      return this.jsonSpec.getValue(input);
    } catch (error) {
      return `${error}`;
    }
  }
};

// node_modules/langchain/dist/tools/requests.js
var RequestsGetTool = class extends Tool {
  static lc_name() {
    return "RequestsGetTool";
  }
  constructor(headers = {}, { maxOutputLength } = {}) {
    super(...arguments);
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: headers
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "requests_get"
    });
    Object.defineProperty(this, "maxOutputLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 2e3
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `A portal to the internet. Use this when you need to get specific content from a website.
  Input should be a url string (i.e. "https://www.google.com"). The output will be the text response of the GET request.`
    });
    this.maxOutputLength = maxOutputLength ?? this.maxOutputLength;
  }
  /** @ignore */
  async _call(input) {
    const res = await fetch(input, {
      headers: this.headers
    });
    const text = await res.text();
    return text.slice(0, this.maxOutputLength);
  }
};
var RequestsPostTool = class extends Tool {
  static lc_name() {
    return "RequestsPostTool";
  }
  constructor(headers = {}, { maxOutputLength } = {}) {
    super(...arguments);
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: headers
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "requests_post"
    });
    Object.defineProperty(this, "maxOutputLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Infinity
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `Use this when you want to POST to a website.
  Input should be a json string with two keys: "url" and "data".
  The value of "url" should be a string, and the value of "data" should be a dictionary of
  key-value pairs you want to POST to the url as a JSON body.
  Be careful to always use double quotes for strings in the json string
  The output will be the text response of the POST request.`
    });
    this.maxOutputLength = maxOutputLength ?? this.maxOutputLength;
  }
  /** @ignore */
  async _call(input) {
    try {
      const { url, data } = JSON.parse(input);
      const res = await fetch(url, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(data)
      });
      const text = await res.text();
      return text.slice(0, this.maxOutputLength);
    } catch (error) {
      return `${error}`;
    }
  }
};

// node_modules/langchain/dist/tools/vectorstore.js
var VectorStoreQATool = class extends Tool {
  static lc_name() {
    return "VectorStoreQATool";
  }
  constructor(name, description, fields) {
    super(...arguments);
    Object.defineProperty(this, "vectorStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "llm", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "chain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name;
    this.description = description;
    this.vectorStore = fields.vectorStore;
    this.llm = fields.llm;
    this.chain = VectorDBQAChain.fromLLM(this.llm, this.vectorStore);
  }
  /**
   * Returns a string that describes what the tool does.
   * @param name The name of the tool.
   * @param description A description of what the tool does.
   * @returns A string that describes what the tool does.
   */
  static getDescription(name, description) {
    return `Useful for when you need to answer questions about ${name}. Whenever you need information about ${description} you should ALWAYS use this. Input should be a fully formed question.`;
  }
  /** @ignore */
  async _call(input) {
    return this.chain.run(input);
  }
};

// node_modules/langchain/dist/tools/fs.js
var ReadFileTool = class extends StructuredTool {
  static lc_name() {
    return "ReadFileTool";
  }
  constructor({ store }) {
    super(...arguments);
    Object.defineProperty(this, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: external_exports.object({
        file_path: external_exports.string().describe("name of file")
      })
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "read_file"
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Read file from disk"
    });
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.store = store;
  }
  async _call({ file_path }) {
    return await this.store.readFile(file_path);
  }
};
var WriteFileTool = class extends StructuredTool {
  static lc_name() {
    return "WriteFileTool";
  }
  constructor({ store, ...rest }) {
    super(rest);
    Object.defineProperty(this, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: external_exports.object({
        file_path: external_exports.string().describe("name of file"),
        text: external_exports.string().describe("text to write to file")
      })
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "write_file"
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Write file from disk"
    });
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.store = store;
  }
  async _call({ file_path, text }) {
    await this.store.writeFile(file_path, text);
    return "File written to successfully.";
  }
};
export {
  ChainTool,
  DynamicStructuredTool,
  DynamicTool,
  JsonGetValueTool,
  JsonListKeysTool,
  JsonSpec,
  ReadFileTool,
  RequestsGetTool,
  RequestsPostTool,
  StructuredTool,
  Tool,
  VectorStoreQATool,
  WriteFileTool,
  convertToOpenAIFunction as formatToOpenAIFunction,
  convertToOpenAITool as formatToOpenAITool
};
//# sourceMappingURL=langchain_tools.js.map
